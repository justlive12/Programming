#include <iostream>
#include <vector>
#include <fstream>

std::ostream& operator<< (std::ostream& stream, std::vector<int>& vec) {
	stream << vec.size() << "\t|";
	for (auto& elem : vec) {
		stream << ' ' << &elem;
	}
	return stream;
}

int main() {
	std::vector<int> vec;
	std::ofstream file("data.txt");

	for (int i = 0; i < 64; ++i) {
		vec.push_back(0);
		file << vec << "\n";
	}
	file << "\n";

	while (!vec.empty()) {
		vec.pop_back();
		file << vec << "\n";
	}
}

/* Вопрос 1.
При одинаковой длине вектора, каждый последующий адрес элемента вектора отличается
на 4 байта (размерность int). Если выделенной памяти для вектора достаточно для
добавления нового элемента, то все адреса чисел int сохраняются, а новый элемент смещается на 4 байта
от предыдущего. Если выделенной памяти недостаточно, то выделяется новая память для вектора.
Все значения старого копируются в новую выделенную область, при этом изменяются адреса значений вектора.

/* Вопрос 2
Если выделенной памяти недостаточно для добавления 25-го элемента,
приложение выделит новую виртуальную память для данных вектора и значение 15-го элемента не изменится */

/*Вопрос 3.
При использовании метода pop_back приложение уменьшает размер вектора на единицу. */

/* Вопрос 4
Результаты отличаются, так как во втором случае передается копия вектора, для которого конструктор выделит
новый регион памяти. */